<template>
  <AzureMapDataSource v-if="hasPosition">
    <AzureMapCircle
      v-if="showAccuracy && radius"
      :longitude="longitude"
      :latitude="latitude"
      :radius="radius"
      @[circleEventName]="$emit(circleEventName, $event)"
    />
    <AzureMapPoint :longitude="longitude" :latitude="latitude" />
    <AzureMapPolygonLayer
      v-if="showAccuracy"
      :options="polygonLayerOptions || undefined"
    />
    <AzureMapSymbolLayer :options="userPositionSymbolLayerOptions" />
  </AzureMapDataSource>
</template>

<script lang="ts">
import { getMapInjection } from '@/plugin/utils/dependency-injection'
import getOptionsFromProps from '@/plugin/utils/get-options-from-props'
import * as atlas from 'azure-maps-control'
import { defineComponent, PropType } from 'vue'

enum AzureMapUserPositionEvent {
  Success = 'success',
  Error = 'error',
  PermissionDenied = 'permission-denied',
  PositionUnavailable = 'permission-unavailable',
  Timeout = 'timeout',
  UnknownError = 'unknown-error',
  Ready = 'ready',
}

export default defineComponent({
  name: 'AzureMapUserPosition',

  components: {
    AzureMapDataSource: () =>
      import(
        /* webpackChunkName: 'AzureMapDataSource.vue' */
        '@/plugin/components/AzureMapDataSource.vue'
      ),
    AzureMapCircle: () =>
      import(
        /* webpackChunkName: 'AzureMapCircle.vue' */
        '@/plugin/components/geometries/AzureMapCircle.vue'
      ),
    AzureMapPoint: () =>
      import(
        /* webpackChunkName: 'AzureMapPoint.vue' */
        '@/plugin/components/geometries/AzureMapPoint.vue'
      ),
    AzureMapPolygonLayer: () =>
      import(
        /* webpackChunkName: 'AzureMapPolygonLayer.vue' */
        '@/plugin/components/layers/AzureMapPolygonLayer.vue'
      ),
    AzureMapSymbolLayer: () =>
      import(
        /* webpackChunkName: 'AzureMapSymbolLayer.vue' */
        '@/plugin/components/layers/AzureMapSymbolLayer.vue'
      ),
  },

  /**
   * Inject the `getMap` function to get the `atlas.Map` instance
   */
  inject: ['getMap'],

  props: {
    /**
     * Indicates the application would like to receive the best possible results.
     * If true and if the device is able to provide a more accurate position, it will do so.
     */
    enableHighAccuracy: {
      type: Boolean,
      default: false,
    },

    /**
     * integer (milliseconds]) | infinity - maximum cached position age.
     */
    maximumAge: {
      type: Number,
      default: null,
    },

    /**
     * integer (milliseconds]) - amount of time before the error callback is invoked, if 0 it will never invoke.
     */
    timeout: {
      type: Number,
      default: null,
    },

    /**
     * Flag that controls if an accuracy circle polygon will be shown
     */
    showAccuracy: {
      type: Boolean,
      default: false,
    },

    /**
     * Override the user position accuracy used for the circle polygon radius
     */
    accuracy: {
      type: Number,
      default: null,
    },

    /**
     * Flag that controls if the map will center on the users position
     */
    centerMapToUserPosition: {
      type: Boolean,
      default: false,
    },

    /**
     * The symbol layer options for the user position point
     */
    symbolLayerOptions: {
      type: Object as PropType<null | atlas.SymbolLayerOptions>,
      default: null,
    },

    /**
     * If `centerMapToUserPosition` is true, this options are passed to the `map.setCamera` method
     */
    cameraOptions: {
      type: Object as PropType<
        | null
        | (atlas.CameraOptions & atlas.AnimationOptions)
        | (atlas.CameraBoundsOptions & atlas.AnimationOptions)
      >,
      default: null,
    },

    /**
     * The polygon layer options for the accuracy circle polygon
     */
    polygonLayerOptions: {
      type: Object as PropType<null | atlas.PolygonLayerOptions>,
      default: null,
    },
  },
  emits: Object.values(AzureMapUserPositionEvent),
  data() {
    return {
      longitude: null as number | null,
      latitude: null as number | null,
      radius: null as number | null,
      defaultSymbolLayerOptions: {
        filter: [
          'any',
          ['==', ['geometry-type'], 'Point'],
          ['==', ['geometry-type'], 'MultiPoint'],
        ], // Only render Point or MultiPoints in this layer.
      },
      hasPosition: false,
      error: null as GeolocationPositionError | null,
    }
  },

  computed: {
    circleEventName(): string {
      return this.showAccuracy ? 'circle-coordinates' : ''
    },

    userPositionSymbolLayerOptions(): Record<string, unknown> {
      return {
        ...(this.symbolLayerOptions || {}),
        ...this.defaultSymbolLayerOptions,
      }
    },
  },

  created() {
    const { enableHighAccuracy, maximumAge, timeout } = this

    navigator.geolocation.getCurrentPosition(
      (position) => {
        // Clear any error
        this.error = null
        this.$emit(AzureMapUserPositionEvent.Success, position)

        // Look for the injected function that retreives the map instance
        const getMap = getMapInjection(this)

        if (!getMap) return

        // Retrieve the map instance from the injected function
        const map = getMap()

        const { longitude, latitude, accuracy } = position.coords

        this.longitude = longitude

        this.latitude = latitude

        if (this.showAccuracy) {
          // Create accuracy circle polygon
          this.radius = this.accuracy || accuracy
        }

        this.hasPosition = true

        if (this.centerMapToUserPosition) {
          // Center the map on the users position.
          map.setCamera({
            ...(this.cameraOptions || {}),
            center: [this.longitude, this.latitude],
          })
        }

        this.$emit(AzureMapUserPositionEvent.Ready)
      },
      (error) => {
        // If an error occurs when trying to access the users position information, emit it with an error message.
        this.hasPosition = false
        this.error = error

        let errorEvent: AzureMapUserPositionEvent
        let errorMessage: string

        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorEvent = AzureMapUserPositionEvent.PermissionDenied
            errorMessage = 'User denied the request for Geolocation.'
            break
          case error.POSITION_UNAVAILABLE:
            errorEvent = AzureMapUserPositionEvent.PositionUnavailable
            errorMessage = 'Position information is unavailable.'
            break
          case error.TIMEOUT:
            errorEvent = AzureMapUserPositionEvent.Timeout
            errorMessage = 'The request to get user position timed out.'
            break
          default:
            errorEvent = AzureMapUserPositionEvent.UnknownError
            errorMessage = 'An unknown error occurred.'
            break
        }

        this.$emit(errorEvent, errorMessage)
        this.$emit(AzureMapUserPositionEvent.Error)
      },
      getOptionsFromProps({
        props: {
          enableHighAccuracy,
          maximumAge,
          timeout,
        },
      })
    )
  },
})
</script>
